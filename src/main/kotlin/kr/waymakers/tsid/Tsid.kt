/*
 * MIT License
 *
 * Copyright (c) 2020-2022 Fabio Lima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package kr.waymakers.tsid

import java.io.Serializable
import java.math.BigInteger
import java.nio.ByteBuffer
import java.time.Instant
import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import kotlin.math.ceil
import kotlin.math.ln

/**
 * A value object that represents a Time-Sorted Unique Identifier (TSID).
 *
 *
 * TSID is a 64-bit value that has 2 components:
 *
 *  * **Time component (42 bits)**: a number of milliseconds since
 * 2020-01-01T00:00:00.000Z.
 *  * **Random component (22 bits)**: a sequence of random bits generated by
 * a secure random generator.
 *
 *
 *
 * The Random component has 2 sub-parts:
 *
 *  * **Node (0 to 20 bits)**: a number used to identify the machine or
 * node.
 *  * **Counter (2 to 22 bits)**: a randomly generated number that is
 * incremented whenever the time component is repeated.
 *
 *
 *
 * The random component layout depend on the node bits. If the node bits are 10,
 * the counter bits are limited to 12. In this example, the maximum node value
 * is 2^10-1 = 1023 and the maximum counter value is 2^12-1 = 4093. So the
 * maximum TSIDs that can be generated per millisecond per node is 4096.
 *
 *
 * Instances of this class are **immutable**.
 *
 * @see [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID)
 *
 * Creates a new TSID.
 *
 *
 * This constructor wraps the input value in an immutable object.
 *
 * @param number a number
 */
class Tsid(
	/**
	 * The internal value.
	 */
	private val number: Long
) : Serializable, Comparable<Tsid> {
	/**
	 * Converts the TSID into a number.
	 *
	 *
	 * This method simply unwraps the internal value.
	 *
	 * @return an number.
	 */
	fun toLong(): Long {
		return this.number
	}

	/**
	 * Converts the TSID into a byte array.
	 *
	 * @return an byte array.
	 */
	fun toBytes(): ByteArray {
		val bytes = ByteArray(TSID_BYTES)

		bytes[0x0] = (number ushr 56).toByte()
		bytes[0x1] = (number ushr 48).toByte()
		bytes[0x2] = (number ushr 40).toByte()
		bytes[0x3] = (number ushr 32).toByte()
		bytes[0x4] = (number ushr 24).toByte()
		bytes[0x5] = (number ushr 16).toByte()
		bytes[0x6] = (number ushr 8).toByte()
		bytes[0x7] = number.toByte()

		return bytes
	}

	/**
	 * Converts the TSID into a canonical string in upper case.
	 *
	 *
	 * The output string is 13 characters long and contains only characters from
	 * Crockford's base 32 alphabet.
	 *
	 *
	 * For lower case string, use the shorthand `Tsid.toLowerCase()` instead
	 * of `Tsid.toString().toLowerCase()`.
	 *
	 * @return a TSID string
	 * @see [Crockford's Base 32](https://www.crockford.com/base32.html)
	 */
	override fun toString(): String {
		return toString(ALPHABET_UPPERCASE)
	}

	/**
	 * Converts the TSID into a canonical string in lower case.
	 *
	 *
	 * The output string is 13 characters long and contains only characters from
	 * Crockford's base 32 alphabet.
	 *
	 *
	 * It is faster shorthand for `Tsid.toString().toLowerCase()`.
	 *
	 * @return a string
	 * @see [Crockford's Base 32](https://www.crockford.com/base32.html)
	 */
	fun toLowerCase(): String {
		return toString(ALPHABET_LOWERCASE)
	}

	val instant: Instant
		/**
		 * Returns the instant of creation.
		 *
		 *
		 * The instant of creation is extracted from the time component.
		 *
		 * @return [Instant]
		 */
		get() = Instant.ofEpochMilli(unixMilliseconds)

	/**
	 * Returns the instant of creation.
	 *
	 *
	 * The instant of creation is extracted from the time component.
	 *
	 * @param customEpoch the custom epoch instant
	 * @return [Instant]
	 */
	fun getInstant(customEpoch: Instant): Instant {
		return Instant.ofEpochMilli(getUnixMilliseconds(customEpoch.toEpochMilli()))
	}

	val unixMilliseconds: Long
		/**
		 * Returns the time of creation in milliseconds since 1970-01-01.
		 *
		 *
		 * The time of creation is extracted from the time component.
		 *
		 * @return the number of milliseconds since 1970-01-01
		 */
		get() = this.time + TSID_EPOCH

	/**
	 * Returns the time of creation in milliseconds since 1970-01-01.
	 *
	 *
	 * The time of creation is extracted from the time component.
	 *
	 * @param customEpoch the custom epoch in milliseconds since 1970-01-01
	 * @return the number of milliseconds since 1970-01-01
	 */
	fun getUnixMilliseconds(customEpoch: Long): Long {
		return this.time + customEpoch
	}

	val time: Long
		/**
		 * Returns the time component as a number.
		 *
		 *
		 * The time component is a number between 0 and 2^42-1.
		 *
		 * @return a number of milliseconds.
		 */
		get() = this.number ushr RANDOM_BITS

	val random: Long
		/**
		 * Returns the random component as a number.
		 *
		 *
		 * The time component is a number between 0 and 2^22-1.
		 *
		 * @return a number
		 */
		get() = this.number and RANDOM_MASK.toLong()

	/**
	 * Returns a hash code value for the TSID.
	 */
	override fun hashCode(): Int {
		return (number xor (number ushr 32)).toInt()
	}

	/**
	 * Checks if some other TSID is equal to this one.
	 */
	override fun equals(other: Any?): Boolean {
		if (other == null) return false
		if (other.javaClass != Tsid::class.java) return false
		val that = other as Tsid
		return (this.number == that.number)
	}

	/**
	 * Compares two TSIDs as **unsigned** 64-bit integers.
	 *
	 *
	 * The first of two TSIDs is greater than the second if the most significant
	 * byte in which they differ is greater for the first TSID.
	 *
	 * @param other a TSID to be compared with
	 * @return -1, 0 or 1 as `this` is less than, equal to, or greater than
	 * `that`
	 */
	override fun compareTo(other: Tsid): Int {
		// used to compare as UNSIGNED longs
		val min = Long.MIN_VALUE

		val a = this.number + min
		val b = other.number + min

		if (a > b) return 1
		else if (a < b) return -1

		return 0
	}

	/**
	 * Converts the TSID to a base-n encoded string.
	 *
	 *
	 * Example:
	 *
	 *  * TSID: 0AXS751X00W7C
	 *  * Base: 62
	 *  * Output: 0T5jFDIkmmy
	 *
	 *
	 *
	 * The output string is left padded with zeros.
	 *
	 * @param base a radix between 2 and 62
	 * @return a base-n encoded string
	 * @throws IllegalArgumentException if the base is invalid
	 * @since 5.2.0
	 */
	fun encode(base: Int): String {
		return BaseN.encode(this, base)
	}

	/**
	 * Converts the TSID to a string using a custom format.
	 *
	 *
	 * The custom format uses a placeholder that will be substituted by the TSID
	 * string. Only the first occurrence of a placeholder will replaced.
	 *
	 *
	 * Placeholders:
	 *
	 *  * %S: canonical string in upper case
	 *  * %s: canonical string in lower case
	 *  * %X: hexadecimal in upper case
	 *  * %x: hexadecimal in lower case
	 *  * %d: base-10
	 *  * %z: base-62
	 *
	 *
	 *
	 * Examples:
	 *
	 *  * An key that starts with a letter:
	 *
	 *  * TSID: 0AWE5HZP3SKTK
	 *  * Format: K%S
	 *  * Output: K**0AWE5HZP3SKTK**
	 *
	 *
	 *  * A file name in hexadecimal with a prefix and an extension:
	 *
	 *  * TSID: 0AXFXR5W7VBX0
	 *  * Format: DOC-%X.PDF
	 *  * Output: DOC-**0575FDC1786137D6**.PDF
	 *
	 *
	 *
	 *
	 *
	 * The opposite operation can be done by [Tsid.unformat].
	 *
	 * @param format a custom format
	 * @return a string using a custom format
	 * @throws IllegalArgumentException if the format string is invalid
	 * @since 5.2.0
	 */
	fun format(format: String): String {
		val i = format.indexOf("%")
		require(i >= 0 && i != format.length - 1) { "Invalid format string: $format" }
		val replacement: String
		val longest = 20 // base10 string size
		val placeholder = format[i + 1]

		replacement = when (placeholder) {
			'S' -> toString()
			's' -> toLowerCase()
			'X' -> BaseN.encode(this, 16)
			'x' -> BaseN.encode(this, 16).lowercase(Locale.getDefault())
			'd' -> BaseN.encode(this, 10)
			'z' -> BaseN.encode(this, 62)
			else -> throw IllegalArgumentException("Invalid placeholder: $placeholder")
		}
		return StringBuilder(format.length + longest).append(format).replace(i, i + 2, replacement).toString()
	}

	fun toString(alphabet: CharArray): String {
		val chars = CharArray(TSID_CHARS)

		chars[0x00] = alphabet[((number ushr 60) and 31L).toInt()]
		chars[0x01] = alphabet[((number ushr 55) and 31L).toInt()]
		chars[0x02] = alphabet[((number ushr 50) and 31L).toInt()]
		chars[0x03] = alphabet[((number ushr 45) and 31L).toInt()]
		chars[0x04] = alphabet[((number ushr 40) and 31L).toInt()]
		chars[0x05] = alphabet[((number ushr 35) and 31L).toInt()]
		chars[0x06] = alphabet[((number ushr 30) and 31L).toInt()]
		chars[0x07] = alphabet[((number ushr 25) and 31L).toInt()]
		chars[0x08] = alphabet[((number ushr 20) and 31L).toInt()]
		chars[0x09] = alphabet[((number ushr 15) and 31L).toInt()]
		chars[0x0a] = alphabet[((number ushr 10) and 31L).toInt()]
		chars[0x0b] = alphabet[((number ushr 5) and 31L).toInt()]
		chars[0x0c] = alphabet[(number and 31L).toInt()]

		return String(chars)
	}

	internal object BaseN {
		private val MAX: BigInteger = BigInteger.valueOf(2).pow(64).subtract(BigInteger.ONE)
		const val ALPHABET: String = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" // base-62

		fun encode(tsid: Tsid, base: Int): String {
			require(base in 2..62) { "Invalid base: $base" }

			var x = tsid.number
			var b = length(base)
			val buffer = CharArray(b)

			while (java.lang.Long.compareUnsigned(x, 0) > 0) {
				val div = java.lang.Long.divideUnsigned(x, base.toLong())
				val rem = java.lang.Long.remainderUnsigned(x, base.toLong())
				buffer[--b] = ALPHABET[rem.toInt()]
				x = div
			}

			while (b > 0) {
				buffer[--b] = '0'
			}
			return String(buffer)
		}

		fun decode(string: String, base: Int): Tsid {
			require(base in 2..62) { "Invalid base: $base" }
			val length = length(base)
			require(string.length == length) { "Invalid base-$base length: ${string.length}" }

			var x = 0L
			var last = 0L
			var plus = 0L
			for (i in 0 until length) {
				plus = ALPHABET.indexOf(string[i]).toLong()
				if (plus == -1L) {
					exception("Invalid base-$base character: ${string[i]}")
				}
				last = x
				x = (x * base) + plus
			}

			// finally, check if happened an overflow
			val buff = ByteBuffer.allocate(8)
			val bytes = buff.putLong(last).array()
			val lazt = BigInteger(1, bytes)
			val baze = BigInteger.valueOf(base.toLong())
			val pluz = BigInteger.valueOf(plus)
			require(lazt.multiply(baze).add(pluz) <= MAX) { "Invalid base-$base value (overflow): $lazt" }

			return Tsid(x)
		}

		private fun length(base: Int): Int {
			return ceil(java.lang.Long.SIZE / (ln(base.toDouble()) / ln(2.0)))
				.toInt()
		}

		private fun exception(string: String) {
			throw IllegalArgumentException(string)
		}
	}

	private object LazyHolder {
		val counter: AtomicInteger = AtomicInteger(SplittableRandom().nextInt())
	}

	companion object {
		/**
		 * Number of bytes of a TSID.
		 */
		const val TSID_BYTES = 8

		/**
		 * Number of characters of a TSID.
		 */
		const val TSID_CHARS = 13

		/**
		 * Number of milliseconds of 2020-01-01T00:00:00.000Z.
		 */
		val TSID_EPOCH = Instant.parse("2020-01-01T00:00:00.000Z").toEpochMilli()

		const val RANDOM_BITS = 22
		const val RANDOM_MASK: Int = 0x003fffff

		private val ALPHABET_UPPERCASE = "0123456789ABCDEFGHJKMNPQRSTVWXYZ".toCharArray()

		private val ALPHABET_LOWERCASE = "0123456789abcdefghjkmnpqrstvwxyz".toCharArray()

		private val ALPHABET_VALUES = ByteArray(256)

		init {
			// Initialize the alphabet map with -1
			Arrays.fill(ALPHABET_VALUES, (-1).toByte())

			// Map the alphabets chars to values
			for (i in ALPHABET_UPPERCASE.indices) {
				ALPHABET_VALUES[ALPHABET_UPPERCASE[i].code] = i.toByte()
			}
			for (i in ALPHABET_LOWERCASE.indices) {
				ALPHABET_VALUES[ALPHABET_LOWERCASE[i].code] = i.toByte()
			}

			// Upper case OIL
			ALPHABET_VALUES['O'.code] = 0x00
			ALPHABET_VALUES['I'.code] = 0x01
			ALPHABET_VALUES['L'.code] = 0x01

			// Lower case OIL
			ALPHABET_VALUES['o'.code] = 0x00
			ALPHABET_VALUES['i'.code] = 0x01
			ALPHABET_VALUES['l'.code] = 0x01
		}

		/**
		 * Converts a number into a TSID.
		 *
		 *
		 * This method wraps the input value in an immutable object.
		 *
		 * @param number a number
		 * @return a TSID
		 */
		fun from(number: Long): Tsid {
			return Tsid(number)
		}

		/**
		 * Converts a byte array into a TSID.
		 *
		 * @param bytes a byte array
		 * @return a TSID
		 * @throws IllegalArgumentException if bytes are null or its length is not 8
		 */
		fun from(bytes: ByteArray): Tsid {
			require(bytes.size == TSID_BYTES) { "Invalid TSID bytes length" }

			var number: Long = 0

			number = number or ((bytes[0x0].toLong() and 0xffL) shl 56)
			number = number or ((bytes[0x1].toLong() and 0xffL) shl 48)
			number = number or ((bytes[0x2].toLong() and 0xffL) shl 40)
			number = number or ((bytes[0x3].toLong() and 0xffL) shl 32)
			number = number or ((bytes[0x4].toLong() and 0xffL) shl 24)
			number = number or ((bytes[0x5].toLong() and 0xffL) shl 16)
			number = number or ((bytes[0x6].toLong() and 0xffL) shl 8)
			number = number or (bytes[0x7].toLong() and 0xffL)

			return Tsid(number)
		}

		/**
		 * Converts a canonical string into a TSID.
		 *
		 *
		 * The input string must be 13 characters long and must contain only characters
		 * from Crockford's base 32 alphabet.
		 *
		 *
		 * The first character of the input string must be between 0 and F.
		 *
		 * @param string a canonical string
		 * @return a TSID
		 * @throws IllegalArgumentException if the input string is invalid
		 * @see [Crockford's Base 32](https://www.crockford.com/base32.html)
		 */
		fun from(string: String): Tsid {
			val chars = toCharArray(string)

			var number: Long = 0

			number = number or (ALPHABET_VALUES[chars[0x00].code].toLong() shl 60)
			number = number or (ALPHABET_VALUES[chars[0x01].code].toLong() shl 55)
			number = number or (ALPHABET_VALUES[chars[0x02].code].toLong() shl 50)
			number = number or (ALPHABET_VALUES[chars[0x03].code].toLong() shl 45)
			number = number or (ALPHABET_VALUES[chars[0x04].code].toLong() shl 40)
			number = number or (ALPHABET_VALUES[chars[0x05].code].toLong() shl 35)
			number = number or (ALPHABET_VALUES[chars[0x06].code].toLong() shl 30)
			number = number or (ALPHABET_VALUES[chars[0x07].code].toLong() shl 25)
			number = number or (ALPHABET_VALUES[chars[0x08].code].toLong() shl 20)
			number = number or (ALPHABET_VALUES[chars[0x09].code].toLong() shl 15)
			number = number or (ALPHABET_VALUES[chars[0x0a].code].toLong() shl 10)
			number = number or (ALPHABET_VALUES[chars[0x0b].code].toLong() shl 5)
			number = number or ALPHABET_VALUES[chars[0x0c].code].toLong()

			return Tsid(number)
		}

		/**
		 * Returns a fast new TSID.
		 *
		 *
		 * This static method is a quick alternative to [TsidCreator.tsid].
		 *
		 *
		 * It employs [AtomicInteger] to generate up to 2^22 (4,194,304) TSIDs per
		 * millisecond. It can be useful, for example, for logging.
		 *
		 *
		 * Security-sensitive applications that require a cryptographically secure
		 * pseudo-random generator **should** use [TsidCreator.tsid].
		 *
		 *
		 * System property "tsidcreator.node" and environment variable
		 * "TSIDCREATOR_NODE" are ignored by this method. Therefore, there will be
		 * collisions if more than one process is generating TSIDs using this method. In
		 * that case, [TsidCreator.tsid] **should** be used in conjunction
		 * with that property or variable.
		 *
		 * @return a TSID
		 * @see {@link AtomicInteger}
		 *
		 * @since 5.1.0
		 */
		fun fast(): Tsid {
			val time = (System.currentTimeMillis() - TSID_EPOCH) shl RANDOM_BITS
			val tail = (LazyHolder.counter.incrementAndGet() and RANDOM_MASK).toLong()
			return Tsid(time or tail)
		}

		/**
		 * Checks if the input string is valid.
		 *
		 *
		 * The input string must be 13 characters long and must contain only characters
		 * from Crockford's base 32 alphabet.
		 *
		 *
		 * The first character of the input string must be between 0 and F.
		 *
		 * @param string a string
		 * @return true if valid
		 */
		fun isValid(string: String?): Boolean {
			return string != null && isValidCharArray(string.toCharArray())
		}

		/**
		 * Converts a base-n encoded string to a TSID.
		 *
		 *
		 * Example:
		 *
		 *  * String: 05772439BB9F9074
		 *  * Base: 16
		 *  * Output: 0AXS476XSZ43M
		 *
		 *
		 *
		 * The input string must be left padded with zeros.
		 *
		 *
		 * **Note**: this method is CASE-SENSITIVE.
		 *
		 * @param string a base-n encoded string
		 * @param base   a radix between 2 and 62
		 * @return a TSID
		 * @throws IllegalArgumentException if the string or base is invalid
		 * @since 5.2.0
		 */
		fun decode(string: String, base: Int): Tsid {
			return BaseN.decode(string, base)
		}

		/**
		 * Converts a string using a custom format to a TSID.
		 *
		 *
		 * This method does the opposite operation of [Tsid.format].
		 *
		 *
		 * Examples:
		 *
		 *  * An key that starts with a letter:
		 *
		 *  * String: K**0AWE5HZP3SKTK**
		 *  * Format: K%S
		 *  * Output: 0AWE5HZP3SKTK
		 *
		 *
		 *  * A file name in hexadecimal with a prefix and an extension:
		 *
		 *  * String: DOC-**0575FDC1786137D6**.PDF
		 *  * Format: DOC-%X.PDF
		 *  * Output: 0AXFXR5W7VBX0
		 *
		 *
		 *
		 *
		 * @param formatted a string using a custom format
		 * @param format    a custom format
		 * @return a TSID
		 * @throws IllegalArgumentException if the formatted string or the format string
		 * is invalid
		 * @since 5.2.0
		 */
		fun unformat(formatted: String, format: String) : Tsid {
			val i = format.indexOf("%")
			require(i >= 0 && i != format.length - 1) { "Invalid format string: \"$format\"" }

			val head = format.substring(0, i)
			val tail = format.substring(i + 2)

			val placeholder = format[i + 1]
			val length = formatted.length - head.length - tail.length

			if (formatted.startsWith(head) && formatted.endsWith(tail)) {
				val substring = formatted.substring(i, i + length)
				return when (placeholder) {
					'S' -> from(substring)
					's' -> from(substring)
					'X' -> BaseN.decode(substring.uppercase(Locale.getDefault()), 16)
					'x' -> BaseN.decode(substring.uppercase(Locale.getDefault()), 16)
					'd' -> BaseN.decode(substring, 10)
					'z' -> BaseN.decode(substring, 62)
					else -> throw IllegalArgumentException("Invalid placeholder: \"$placeholder\"")
				}
			}
			throw IllegalArgumentException("Invalid formatted string: \"$formatted\"")
		}

		private fun toCharArray(string: String): CharArray {
			val chars = string.toCharArray()
			require(isValidCharArray(chars)) { "Invalid TSID string: \"$string\"" }
			return chars
		}

		/**
		 * Checks if the string is a valid TSID.
		 *
		 * A valid TSID string is a sequence of 13 characters from Crockford's base 32
		 * alphabet.
		 *
		 * The first character of the input string must be between 0 and F.
		 *
		 * @param chars a char array
		 * @return boolean true if valid
		 */
		private fun isValidCharArray(chars: CharArray): Boolean {
			if (chars.size != TSID_CHARS) {
				return false // null or wrong size!
			}

			for (i in chars.indices) {
				try {
					if (ALPHABET_VALUES[chars[i].code].toInt() == -1) {
						return false // invalid character!
					}
				} catch (e: ArrayIndexOutOfBoundsException) {
					return false // multibyte character!
				}
			}

			// The extra bit added by base-32 encoding must be zero
			// As a consequence, the 1st char of the input string must be between 0 and F.
			if ((ALPHABET_VALUES[chars[0].code].toInt() and 16) != 0) {
				return false // overflow!
			}

			return true // It seems to be OK.
		}
	}
}
